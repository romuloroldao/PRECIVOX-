// backend/routes/ai.js
// Rotas para an√°lises AI reais usando Groq

import express from 'express';
import Groq from 'groq-sdk';

const router = express.Router();

// Inicializar Groq SDK (opcional)
let groq = null;
try {
  if (process.env.GROQ_API_KEY) {
    groq = new Groq({
      apiKey: process.env.GROQ_API_KEY
    });
  }
} catch (error) {
  console.warn('‚ö†Ô∏è Groq SDK n√£o inicializado - API key n√£o encontrada');
}

/**
 * Health check do servi√ßo AI
 */
router.get('/health', (req, res) => {
  const hasApiKey = !!process.env.GROQ_API_KEY;
  
  res.json({
    status: 'ok',
    service: 'AI Analysis Service',
    groq_configured: hasApiKey,
    timestamp: new Date().toISOString()
  });
});

/**
 * An√°lise completa da lista de compras
 */
router.post('/analyze-list', async (req, res) => {
  try {
    const { listItems, userLocation, userPreferences, sessionId } = req.body;
    
    console.log('üß† [AI] Analisando lista com', listItems?.length || 0, 'itens');
    
    if (!listItems || !Array.isArray(listItems) || listItems.length === 0) {
      return res.status(400).json({
        error: 'Lista de itens √© obrigat√≥ria e deve conter pelo menos um item'
      });
    }

    // Verificar se Groq est√° configurado
    if (!process.env.GROQ_API_KEY) {
      console.warn('‚ö†Ô∏è GROQ_API_KEY n√£o configurada, usando an√°lise mock');
      return res.json(generateMockAnalysis(listItems));
    }

    // Preparar prompt para a IA
    const listSummary = listItems.map(item => 
      `${item.produto.nome} - R$${item.produto.preco} (${item.quantidade}x) - ${item.produto.loja || 'Loja n√£o especificada'}`
    ).join('\n');

    const totalValue = listItems.reduce((sum, item) => 
      sum + (item.produto.preco * item.quantidade), 0
    );

    const prompt = `
Analise esta lista de compras e forne√ßa insights para otimiza√ß√£o:

LISTA DE COMPRAS:
${listSummary}

VALOR TOTAL: R$${totalValue.toFixed(2)}
TOTAL DE ITENS: ${listItems.length}

Por favor, forne√ßa uma an√°lise estruturada em JSON com:
1. Economia estimada poss√≠vel
2. Score de efici√™ncia (0-100)
3. Sugest√µes de otimiza√ß√£o
4. Alternativas de produtos
5. Insights sobre pre√ßos e disponibilidade

Responda apenas com JSON v√°lido.`;

    console.log('ü§ñ Enviando prompt para Groq...');

    // Chamar Groq API
    const completion = await groq.chat.completions.create({
      messages: [
        {
          role: 'system',
          content: 'Voc√™ √© um especialista em otimiza√ß√£o de compras e an√°lise de pre√ßos. Analise listas de compras e forne√ßa insights valiosos para economia e efici√™ncia. Sempre responda em JSON v√°lido em portugu√™s brasileiro.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      model: 'llama-3.1-70b-versatile',
      temperature: 0.3,
      max_tokens: 2048
    });

    const aiResponse = completion.choices[0]?.message?.content;
    
    if (!aiResponse) {
      throw new Error('Resposta vazia da IA');
    }

    console.log('‚úÖ Resposta recebida da IA');

    try {
      // Tentar parsear a resposta JSON da IA
      const analysis = JSON.parse(aiResponse);
      
      // Estruturar resposta no formato esperado pelo frontend
      const structuredResponse = {
        sessionId,
        timestamp: new Date().toISOString(),
        analysis: {
          totalCost: totalValue,
          estimatedSavings: analysis.economia_estimada || totalValue * 0.1,
          efficiencyScore: analysis.score_eficiencia || 75,
          routeOptimization: {
            currentRoute: extractStores(listItems),
            optimizedRoute: analysis.rota_otimizada || extractStores(listItems),
            timeSaved: analysis.tempo_economizado || 0,
            fuelSaved: analysis.combustivel_economizado || 0
          },
          insights: analysis.insights || [
            'An√°lise AI conclu√≠da com sucesso',
            `Lista com ${listItems.length} itens analisada`
          ],
          warnings: analysis.avisos || []
        },
        suggestions: analysis.sugestoes || [],
        alternatives: analysis.alternativas || [],
        marketAnalysis: analysis.analise_mercados || [],
        metadata: {
          model: 'llama-3.1-70b-versatile',
          processingTime: Date.now() - Date.now(),
          confidence: analysis.confianca || 0.8
        }
      };

      res.json(structuredResponse);

    } catch (parseError) {
      console.error('‚ùå Erro ao parsear resposta da IA:', parseError);
      console.log('Raw AI Response:', aiResponse);
      
      // Fallback com an√°lise b√°sica baseada na resposta text
      res.json({
        sessionId,
        timestamp: new Date().toISOString(),
        analysis: {
          totalCost: totalValue,
          estimatedSavings: totalValue * 0.1,
          efficiencyScore: 70,
          routeOptimization: {
            currentRoute: extractStores(listItems),
            optimizedRoute: extractStores(listItems),
            timeSaved: 0,
            fuelSaved: 0
          },
          insights: [
            'An√°lise AI processada com resposta textual',
            aiResponse.substring(0, 200) + '...'
          ],
          warnings: ['Resposta AI em formato n√£o estruturado']
        },
        suggestions: [],
        alternatives: [],
        marketAnalysis: [],
        rawAIResponse: aiResponse
      });
    }

  } catch (error) {
    console.error('‚ùå Erro na an√°lise AI:', error);
    
    res.status(500).json({
      error: 'Erro interno na an√°lise AI',
      message: error.message,
      fallback: generateMockAnalysis(req.body.listItems || [])
    });
  }
});

/**
 * Buscar alternativas para um produto espec√≠fico
 */
router.post('/product-alternatives', async (req, res) => {
  try {
    const { product, context } = req.body;
    
    if (!product) {
      return res.status(400).json({ error: 'Produto √© obrigat√≥rio' });
    }

    console.log('üîç [AI] Buscando alternativas para:', product.nome);

    if (!process.env.GROQ_API_KEY) {
      return res.json({
        originalProduct: product,
        alternatives: []
      });
    }

    const prompt = `
Encontre alternativas para este produto:

PRODUTO: ${product.nome}
PRE√áO ATUAL: R$${product.preco}
LOJA ATUAL: ${product.loja}
CATEGORIA: ${product.categoria}

Contexto da lista: ${context?.length || 0} itens total

Forne√ßa alternativas em JSON com produtos similares, compara√ß√£o de pre√ßos e recomenda√ß√µes.`;

    const completion = await groq.chat.completions.create({
      messages: [
        {
          role: 'system',
          content: 'Voc√™ √© um especialista em produtos de supermercado. Sugira alternativas para produtos considerando pre√ßo, qualidade e disponibilidade.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      model: 'llama-3.1-70b-versatile',
      temperature: 0.2,
      max_tokens: 1024
    });

    const aiResponse = completion.choices[0]?.message?.content;
    
    try {
      const alternatives = JSON.parse(aiResponse);
      res.json({
        originalProduct: product,
        alternatives: alternatives.alternativas || [],
        timestamp: new Date().toISOString()
      });
    } catch (parseError) {
      res.json({
        originalProduct: product,
        alternatives: [],
        rawResponse: aiResponse
      });
    }

  } catch (error) {
    console.error('‚ùå Erro ao buscar alternativas:', error);
    res.status(500).json({
      error: 'Erro ao buscar alternativas',
      originalProduct: req.body.product,
      alternatives: []
    });
  }
});

/**
 * Otimizar rota de compras
 */
router.post('/optimize-route', async (req, res) => {
  try {
    const { items, userLocation } = req.body;
    
    console.log('üó∫Ô∏è [AI] Otimizando rota para', items?.length || 0, 'itens');
    
    if (!items || !Array.isArray(items)) {
      return res.status(400).json({ error: 'Lista de itens √© obrigat√≥ria' });
    }

    // Extrair lojas √∫nicas
    const stores = extractStores(items);
    
    if (!process.env.GROQ_API_KEY) {
      return res.json({
        optimizedRoute: stores.map(store => ({
          store,
          items: items.filter(item => item.produto.loja === store),
          totalCost: 0,
          distance: 0,
          estimatedTime: 30,
          pros: ['Loja dispon√≠vel'],
          cons: [],
          recommendation: 'acceptable'
        })),
        savings: { time: 0, fuel: 0 },
        confidence: 0.5
      });
    }

    const storesList = stores.join(', ');
    const itemsList = items.map(item => 
      `${item.produto.nome} (${item.produto.loja})`
    ).join(', ');

    const prompt = `
Otimize a rota de compras para estas lojas e itens:

LOJAS: ${storesList}
ITENS: ${itemsList}
${userLocation ? `LOCALIZA√á√ÉO DO USU√ÅRIO: Lat ${userLocation.lat}, Lng ${userLocation.lng}` : ''}

Sugira a melhor ordem de visita √†s lojas considerando:
1. Economia de tempo e combust√≠vel
2. Disponibilidade dos produtos
3. Pre√ßos competitivos
4. Dist√¢ncia entre lojas

Responda em JSON com rota otimizada e economia estimada.`;

    const completion = await groq.chat.completions.create({
      messages: [
        {
          role: 'system',
          content: 'Voc√™ √© um especialista em log√≠stica e otimiza√ß√£o de rotas. Ajude a planejar rotas eficientes para compras.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      model: 'llama-3.1-70b-versatile',
      temperature: 0.2,
      max_tokens: 1536
    });

    const aiResponse = completion.choices[0]?.message?.content;
    
    try {
      const routeOptimization = JSON.parse(aiResponse);
      res.json({
        optimizedRoute: routeOptimization.rota_otimizada || [],
        savings: routeOptimization.economia || { time: 0, fuel: 0 },
        confidence: routeOptimization.confianca || 0.7,
        timestamp: new Date().toISOString()
      });
    } catch (parseError) {
      res.json({
        optimizedRoute: [],
        savings: { time: 0, fuel: 0 },
        confidence: 0.3,
        rawResponse: aiResponse
      });
    }

  } catch (error) {
    console.error('‚ùå Erro na otimiza√ß√£o de rota:', error);
    res.status(500).json({
      error: 'Erro na otimiza√ß√£o de rota',
      optimizedRoute: [],
      savings: { time: 0, fuel: 0 },
      confidence: 0
    });
  }
});

// ========================================
// FUN√á√ïES AUXILIARES
// ========================================

/**
 * Extrair lojas √∫nicas da lista de itens
 */
function extractStores(items) {
  const stores = new Set();
  items.forEach(item => {
    if (item.produto && item.produto.loja) {
      stores.add(item.produto.loja);
    }
  });
  return Array.from(stores);
}

/**
 * Gerar an√°lise mock quando IA n√£o est√° dispon√≠vel
 */
function generateMockAnalysis(listItems) {
  const totalValue = listItems.reduce((sum, item) => 
    sum + (item.produto.preco * item.quantidade), 0
  );

  return {
    sessionId: `mock_${Date.now()}`,
    timestamp: new Date().toISOString(),
    analysis: {
      totalCost: totalValue,
      estimatedSavings: totalValue * 0.08,
      efficiencyScore: 72,
      routeOptimization: {
        currentRoute: extractStores(listItems),
        optimizedRoute: extractStores(listItems),
        timeSaved: 5,
        fuelSaved: 3.50
      },
      insights: [
        `Lista com ${listItems.length} itens analisada (modo offline)`,
        `Valor total: R$${totalValue.toFixed(2)}`,
        'Conecte-se √† internet para an√°lise AI completa'
      ],
      warnings: ['An√°lise em modo offline - funcionalidade limitada']
    },
    suggestions: [
      {
        id: 'mock_suggestion_1',
        type: 'price_optimization',
        title: 'Oportunidade de economia identificada',
        description: 'Alguns produtos podem ter alternativas mais baratas',
        impact: {
          savings: totalValue * 0.05,
          timeReduction: 0,
          qualityImpact: 'neutral'
        },
        confidence: 0.6,
        actionable: false
      }
    ],
    alternatives: [],
    marketAnalysis: extractStores(listItems).map(store => ({
      store,
      items: listItems.filter(item => item.produto.loja === store),
      totalCost: listItems
        .filter(item => item.produto.loja === store)
        .reduce((sum, item) => sum + (item.produto.preco * item.quantidade), 0),
      distance: 0,
      estimatedTime: 20,
      pros: ['Produtos dispon√≠veis'],
      cons: ['An√°lise limitada (offline)'],
      recommendation: 'acceptable'
    })),
    metadata: {
      model: 'mock',
      processingTime: 100,
      confidence: 0.5
    }
  };
}

/**
 * An√°lise inteligente de pre√ßos baseada nos dados dos mercados
 */
router.post('/analyze-prices', async (req, res) => {
  try {
    const { products, market_ids, user_location } = req.body;
    
    console.log('üí∞ [AI] Analisando pre√ßos para', products?.length || 0, 'produtos');
    
    if (!products || !Array.isArray(products) || products.length === 0) {
      return res.status(400).json({
        error: 'Lista de produtos √© obrigat√≥ria'
      });
    }

    // Buscar dados reais dos mercados no banco
    let marketData = [];
    for (const product of products) {
      const query = `
        SELECT 
          p.name, p.category, p.price, p.promotional_price, p.is_promotion,
          p.discount_percentage, p.brand, p.barcode, p.stock_quantity,
          m.name as market_name, m.slug as market_slug,
          m.address_city, m.address_state, m.address_neighborhood
        FROM products p
        JOIN markets m ON p.market_id = m.id
        WHERE p.status = 'active' 
        AND m.status = 'active' 
        AND m.verified = true
        AND (
          LOWER(p.name) LIKE LOWER($1) OR
          p.search_vector @@ plainto_tsquery('portuguese', $2)
        )
        ORDER BY p.price ASC
        LIMIT 20
      `;
      
      const searchTerm = `%${product.name || product.nome}%`;
      const result = await req.db.query(query, [searchTerm, product.name || product.nome]);
      
      if (result.rows.length > 0) {
        marketData.push({
          searchedProduct: product,
          matches: result.rows
        });
      }
    }

    if (marketData.length === 0) {
      return res.json({
        analysis: {
          message: 'Nenhum produto encontrado nos mercados cadastrados',
          searchedProducts: products.length
        },
        suggestions: [],
        alternatives: []
      });
    }

    // Preparar dados para an√°lise AI
    const marketAnalysis = marketData.map(data => {
      const matches = data.matches;
      const prices = matches.map(m => m.promotional_price || m.price);
      const avgPrice = prices.reduce((sum, price) => sum + price, 0) / prices.length;
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      
      return {
        product: data.searchedProduct.name || data.searchedProduct.nome,
        found_matches: matches.length,
        price_range: {
          min: minPrice,
          max: maxPrice,
          average: avgPrice
        },
        best_offers: matches.slice(0, 3).map(m => ({
          market: m.market_name,
          price: m.promotional_price || m.price,
          original_price: m.promotional_price ? m.price : null,
          promotion: m.is_promotion,
          discount: m.discount_percentage,
          location: `${m.address_city}, ${m.address_state}`
        }))
      };
    });

    // An√°lise AI se dispon√≠vel
    if (process.env.GROQ_API_KEY) {
      const analysisData = JSON.stringify(marketAnalysis, null, 2);
      
      const prompt = `
Analise estes dados de pre√ßos de mercados e forne√ßa insights de economia:

DADOS DOS MERCADOS:
${analysisData}

Forne√ßa uma an√°lise estruturada em JSON com:
1. Economia total poss√≠vel por produto
2. Melhores lojas por categoria
3. Padr√µes de pre√ßos identificados
4. Recomenda√ß√µes de compra
5. Alertas sobre produtos caros ou em falta

Responda apenas com JSON v√°lido em portugu√™s brasileiro.`;

      try {
        const completion = await groq.chat.completions.create({
          messages: [
            {
              role: 'system',
              content: 'Voc√™ √© um especialista em an√°lise de pre√ßos de supermercados. Analise dados de mercados reais para identificar oportunidades de economia.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          model: 'llama-3.1-70b-versatile',
          temperature: 0.2,
          max_tokens: 2048
        });

        const aiResponse = completion.choices[0]?.message?.content;
        
        try {
          const aiAnalysis = JSON.parse(aiResponse);
          
          return res.json({
            analysis: {
              total_products_searched: products.length,
              products_found: marketData.length,
              markets_analyzed: [...new Set(marketData.flatMap(d => d.matches.map(m => m.market_name)))].length,
              ai_insights: aiAnalysis.insights || [],
              total_savings_potential: aiAnalysis.economia_total || 0,
              best_markets: aiAnalysis.melhores_lojas || []
            },
            product_analysis: marketAnalysis,
            suggestions: aiAnalysis.recomendacoes || [],
            alerts: aiAnalysis.alertas || [],
            timestamp: new Date().toISOString()
          });
          
        } catch (parseError) {
          console.error('Erro ao parsear an√°lise AI:', parseError);
          // Continuar com an√°lise b√°sica
        }
      } catch (aiError) {
        console.error('Erro na chamada AI:', aiError);
        // Continuar com an√°lise b√°sica
      }
    }

    // An√°lise b√°sica sem AI
    const totalSavingsPotential = marketAnalysis.reduce((sum, analysis) => {
      return sum + (analysis.price_range.max - analysis.price_range.min);
    }, 0);

    const bestMarkets = {};
    marketData.forEach(data => {
      data.matches.forEach(match => {
        if (!bestMarkets[match.market_name]) {
          bestMarkets[match.market_name] = {
            name: match.market_name,
            location: `${match.address_city}, ${match.address_state}`,
            product_count: 0,
            avg_savings: 0,
            best_deals: []
          };
        }
        bestMarkets[match.market_name].product_count++;
        
        if (match.is_promotion) {
          bestMarkets[match.market_name].best_deals.push({
            product: match.name,
            price: match.promotional_price,
            discount: match.discount_percentage
          });
        }
      });
    });

    res.json({
      analysis: {
        total_products_searched: products.length,
        products_found: marketData.length,
        markets_analyzed: Object.keys(bestMarkets).length,
        total_savings_potential: totalSavingsPotential,
        best_markets: Object.values(bestMarkets).slice(0, 5)
      },
      product_analysis: marketAnalysis,
      suggestions: [
        {
          type: 'price_comparison',
          title: 'Compare pre√ßos entre mercados',
          description: `Encontramos ${marketData.length} produtos em diferentes mercados com varia√ß√£o de pre√ßos`,
          savings_potential: totalSavingsPotential
        }
      ],
      alerts: marketAnalysis
        .filter(analysis => analysis.found_matches === 0)
        .map(analysis => ({
          type: 'product_not_found',
          product: analysis.product,
          message: 'Produto n√£o encontrado nos mercados cadastrados'
        })),
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Erro na an√°lise de pre√ßos:', error);
    res.status(500).json({
      error: 'Erro interno na an√°lise de pre√ßos',
      message: error.message
    });
  }
});

/**
 * Relat√≥rio de tend√™ncias de pre√ßos
 */
router.get('/price-trends', async (req, res) => {
  try {
    const { category, market_id, days = 30 } = req.query;
    
    console.log('üìà [AI] Analisando tend√™ncias de pre√ßos');
    
    let sql = `
      SELECT 
        p.category,
        p.name,
        p.price,
        p.promotional_price,
        p.is_promotion,
        p.created_at,
        p.updated_at,
        m.name as market_name,
        COUNT(*) OVER (PARTITION BY p.category) as category_count,
        AVG(p.price) OVER (PARTITION BY p.category) as category_avg_price
      FROM products p
      JOIN markets m ON p.market_id = m.id
      WHERE p.status = 'active' 
      AND m.status = 'active' 
      AND m.verified = true
      AND p.created_at >= CURRENT_DATE - INTERVAL '${days} days'
    `;
    
    const values = [];
    let paramCount = 0;
    
    if (category) {
      paramCount++;
      sql += ` AND p.category = $${paramCount}`;
      values.push(category);
    }
    
    if (market_id) {
      paramCount++;
      sql += ` AND m.id = $${paramCount}`;
      values.push(market_id);
    }
    
    sql += ` ORDER BY p.category, p.price ASC`;
    
    const result = await req.db.query(sql, values);
    
    if (result.rows.length === 0) {
      return res.json({
        trends: [],
        summary: {
          message: 'Nenhum dado encontrado para an√°lise de tend√™ncias',
          period: `${days} dias`
        }
      });
    }

    // Agrupar por categoria
    const categoryTrends = {};
    result.rows.forEach(row => {
      if (!categoryTrends[row.category]) {
        categoryTrends[row.category] = {
          category: row.category,
          products: [],
          price_stats: {
            min: Infinity,
            max: -Infinity,
            avg: 0,
            promotion_rate: 0
          }
        };
      }
      
      const finalPrice = row.promotional_price || row.price;
      categoryTrends[row.category].products.push({
        name: row.name,
        price: row.price,
        final_price: finalPrice,
        promotion: row.is_promotion,
        market: row.market_name
      });
      
      // Atualizar estat√≠sticas
      const stats = categoryTrends[row.category].price_stats;
      stats.min = Math.min(stats.min, finalPrice);
      stats.max = Math.max(stats.max, finalPrice);
    });
    
    // Calcular m√©dias e taxas de promo√ß√£o
    Object.values(categoryTrends).forEach(trend => {
      const prices = trend.products.map(p => p.final_price);
      const promotions = trend.products.filter(p => p.promotion).length;
      
      trend.price_stats.avg = prices.reduce((sum, price) => sum + price, 0) / prices.length;
      trend.price_stats.promotion_rate = (promotions / trend.products.length) * 100;
    });

    res.json({
      trends: Object.values(categoryTrends),
      summary: {
        categories_analyzed: Object.keys(categoryTrends).length,
        total_products: result.rows.length,
        period: `${days} dias`,
        most_promoted_category: Object.values(categoryTrends)
          .sort((a, b) => b.price_stats.promotion_rate - a.price_stats.promotion_rate)[0]?.category,
        cheapest_category: Object.values(categoryTrends)
          .sort((a, b) => a.price_stats.avg - b.price_stats.avg)[0]?.category
      },
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Erro na an√°lise de tend√™ncias:', error);
    res.status(500).json({
      error: 'Erro na an√°lise de tend√™ncias',
      message: error.message
    });
  }
});

export default router;