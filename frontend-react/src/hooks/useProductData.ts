// hooks/useProductData.ts - VERS√ÉO CORRIGIDA COM CARREGAMENTO JSON

import { useState, useEffect, useCallback, useRef } from 'react';

// ‚úÖ TIPOS LOCAIS 
interface Product {
  id: string;
  nome: string;
  preco: number;
  categoria: string;
  subcategoria?: string;
  imagem?: string;
  loja: string;
  lojaId?: string;
  descricao?: string;
  distancia?: number;
  promocao?: {
    ativo?: boolean;
    desconto: number;
    precoOriginal: number;
    validoAte?: string;
  } | boolean;
  avaliacao?: number;
  numeroAvaliacoes?: number;
  disponivel: boolean;
  tempoEntrega?: string;
  isNovo?: boolean;
  isMelhorPreco?: boolean;
  marca?: string;
  codigo?: string;
  peso?: string;
  origem?: string;
  visualizacoes?: number;
  conversoes?: number;
  estoque?: number;
  endereco?: string;
  telefone?: string;
  tags?: string[];
}

interface Category {
  id: string;
  label: string;
  icon?: string;
  count?: number;
  color?: string;
  description?: string;
}

type DataSourceType = 'json' | 'api' | 'hybrid' | 'fallback' | 'none';

interface UseProductDataReturn {
  products: Product[];
  allProducts: Product[];
  categories: Category[];
  markets: string[];
  brands: string[];
  loading: boolean;
  dataSource: DataSourceType;
  apiConnected: boolean;
  jsonLoaded: boolean;
  error: string | null;
  loadProducts: () => Promise<void>;
  searchProducts: (query: string) => Promise<Product[]>;
  loadProductsByCategory: (categoryId: string) => Promise<Product[]>;
  reloadData: () => Promise<void>;
  clearCache: () => void;
  getSmartSuggestions: (query?: string) => string[];
  searchTerm: string;
  setSearchTerm: (term: string) => void;
}

// ‚úÖ FUN√á√ÉO PARA TRANSFORMAR JSON ‚Üí PRODUCT (CORRIGIDA)
function transformJSONToProduct(jsonProduct: any): Product {
  // ‚úÖ CORRE√á√ÉO: Calcular disponibilidade corretamente
  const estoque = jsonProduct.estoque || 0;
  const disponivel = jsonProduct.disponivel !== undefined 
    ? Boolean(jsonProduct.disponivel) 
    : estoque > 0;

  // ‚úÖ CORRE√á√ÉO: Calcular promo√ß√£o corretamente
  const precoNumerico = typeof jsonProduct.preco === 'string' 
    ? parseFloat(jsonProduct.preco) 
    : (jsonProduct.preco || 0);
  
  const desconto = jsonProduct.desconto || 0;
  const temPromocao = jsonProduct.promocao === true || desconto > 0;
  
  // Calcular pre√ßo original baseado no desconto
  const precoOriginal = temPromocao && desconto > 0
    ? precoNumerico / (1 - desconto / 100)
    : precoNumerico;

  // ‚úÖ GERAR TAGS INTELIGENTES
  const tags = [];
  
  // Tags do nome
  const nomeWords = (jsonProduct.nome || '').toLowerCase().split(' ');
  nomeWords.forEach((word: string) => {
    if (word.length > 3) tags.push(word);
  });
  
  // Tags da categoria
  if (jsonProduct.categoria) {
    tags.push(jsonProduct.categoria);
  }
  if (jsonProduct.subcategoria) {
    tags.push(jsonProduct.subcategoria);
  }
  
  // Tags da marca
  if (jsonProduct.marca) {
    tags.push(jsonProduct.marca.toLowerCase());
  }

  // ‚úÖ DIST√ÇNCIA ALEAT√ìRIA PARA FRANCO DA ROCHA
  const distanciaAleatoria = Math.random() * 5 + 0.5; // Entre 0.5km e 5.5km

  return {
    id: String(jsonProduct.id),
    nome: jsonProduct.nome || 'Produto sem nome',
    preco: precoNumerico,
    categoria: jsonProduct.categoria || 'outros',
    subcategoria: jsonProduct.subcategoria,
    imagem: jsonProduct.imagem || `/api/placeholder/300/300?text=${encodeURIComponent(jsonProduct.nome || 'Produto')}`,
    loja: jsonProduct.loja || 'Loja n√£o informada',
    lojaId: String(jsonProduct.id),
    descricao: jsonProduct.descricao,
    distancia: jsonProduct.distancia || distanciaAleatoria,
    
    // ‚úÖ CORRE√á√ÉO: Estrutura da promo√ß√£o
    promocao: temPromocao ? {
      ativo: true,
      desconto: desconto,
      precoOriginal: precoOriginal,
      validoAte: jsonProduct.validoAte
    } : false,
    
    avaliacao: jsonProduct.avaliacao || (Math.random() * 2 + 3), // Entre 3 e 5
    numeroAvaliacoes: jsonProduct.numeroAvaliacoes || Math.floor(Math.random() * 100 + 10),
    disponivel: disponivel, // ‚úÖ CORRE√á√ÉO PRINCIPAL
    tempoEntrega: jsonProduct.tempoEntrega || '1-2 dias',
    isNovo: jsonProduct.isNovo || Math.random() > 0.8,
    isMelhorPreco: jsonProduct.isMelhorPreco || false,
    marca: jsonProduct.marca,
    codigo: jsonProduct.codigo || jsonProduct.codigo_barras,
    peso: jsonProduct.peso,
    origem: jsonProduct.origem || 'Nacional',
    visualizacoes: jsonProduct.visualizacoes || Math.floor(Math.random() * 3000 + 500),
    conversoes: jsonProduct.conversoes || Math.floor(Math.random() * 1000 + 100),
    estoque: estoque,
    endereco: jsonProduct.endereco,
    telefone: jsonProduct.telefone,
    tags: [...new Set(tags)]
  };
}

// ‚úÖ BUSCA INTELIGENTE COM SIN√îNIMOS
function searchProducts(products: Product[], query: string): Product[] {
  if (!query.trim()) return products;

  const searchTerm = query.toLowerCase().trim();
  console.log(`üîç Buscando por: "${searchTerm}"`);

  // ‚úÖ MAPA DE SIN√îNIMOS EXPANDIDO
  const synonyms: Record<string, string[]> = {
    // Bebidas
    'refrigerante': ['coca', 'pepsi', 'guaran√°', 'soda', 'refri'],
    'suco': ['juice', 'bebida', 'n√©ctar'],
    '√°gua': ['water', 'mineral', 'bonafont'],
    'cerveja': ['beer', 'heineken', 'brahma', 'stella'],
    
    // Carnes
    'carne': ['bovina', 'frango', 'su√≠na', 'prote√≠na', 'peito', 'contrafil√©', 'picanha'],
    'frango': ['ave', 'peito', 'coxa', 'asas'],
    'peixe': ['pescado', 'atum', 'salm√£o'],
    
    // Limpeza
    'limpeza': ['detergente', 'sab√£o', 'desinfetante', 'cleaning'],
    'sab√£o': ['detergente', 'omo', 'yp√™', 'limpeza'],
    
    // Higiene
    'higiene': ['shampoo', 'sabonete', 'creme dental', 'desodorante'],
    'shampoo': ['cabelo', 'pantene', 'seda'],
    
    // Latic√≠nios
    'leite': ['dairy', 'parmalat', 'l√°cteo'],
    'queijo': ['mussarela', 'prato', 'dairy'],
    
    // Gr√£os
    'arroz': ['cereal', 'gr√£o', 'tio jo√£o', 'camil'],
    'feij√£o': ['gr√£o', 'kicaldo', 'camil'],
    
    // Outros
    'p√£o': ['padaria', 'pullman', 'forma'],
    'caf√©': ['pil√£o', 'orfeu', 'nescaf√©'],
    '√≥leo': ['soja', 'girassol', 'liza'],
    'a√ß√∫car': ['doce', 'uni√£o', 'cristal']
  };

  // Buscar sin√¥nimos
  let expandedTerms = [searchTerm];
  
  // Adicionar sin√¥nimos diretos
  if (synonyms[searchTerm]) {
    expandedTerms.push(...synonyms[searchTerm]);
  }
  
  // Buscar termos que tenham o searchTerm como sin√¥nimo
  Object.entries(synonyms).forEach(([key, values]) => {
    if (values.some(synonym => synonym.includes(searchTerm) || searchTerm.includes(synonym))) {
      expandedTerms.push(key, ...values);
    }
  });

  // Remover duplicatas
  expandedTerms = [...new Set(expandedTerms)];

  console.log(`üéØ Termos expandidos:`, expandedTerms);

  // Filtrar produtos
  const results = products.filter(product => {
    const searchableText = [
      product.nome,
      product.categoria,
      product.subcategoria,
      product.marca,
      product.loja,
      product.descricao,
      ...(product.tags || [])
    ].join(' ').toLowerCase();

    // Verificar se algum termo expandido est√° presente
    return expandedTerms.some(term => 
      searchableText.includes(term) ||
      product.nome.toLowerCase().includes(term) ||
      product.categoria.toLowerCase().includes(term)
    );
  });

  console.log(`‚úÖ Encontrados ${results.length} produtos para "${query}"`);
  return results;
}

// ‚úÖ BUSCA POR CATEGORIA
function searchByCategory(products: Product[], categoryId: string): Product[] {
  if (categoryId === 'all') return products;
  
  return products.filter(product => 
    product.categoria === categoryId ||
    product.categoria.includes(categoryId) ||
    product.subcategoria === categoryId
  );
}

// ‚úÖ GERAR SUGEST√ïES INTELIGENTES
function generateSmartSuggestions(products: Product[], query: string = ''): string[] {
  if (!query.trim()) {
    // Sugest√µes populares quando n√£o h√° busca
    return [
      'Coca Cola', 'Arroz', 'Feij√£o', 'Leite', 'P√£o', 
      'Caf√©', '√ìleo', 'A√ß√∫car', 'Detergente', 'Shampoo'
    ];
  }

  const searchTerm = query.toLowerCase();
  const suggestions: string[] = [];

  // Buscar produtos que come√ßam com o termo
  products.forEach(product => {
    if (product.nome.toLowerCase().startsWith(searchTerm)) {
      suggestions.push(product.nome);
    }
  });

  // Buscar categorias relacionadas
  const categories = [...new Set(products.map(p => p.categoria))];
  categories.forEach(cat => {
    if (cat.toLowerCase().includes(searchTerm)) {
      suggestions.push(cat.charAt(0).toUpperCase() + cat.slice(1));
    }
  });

  return [...new Set(suggestions)].slice(0, 8);
}

// ‚úÖ PROCESSAR DADOS JSON
function processJSONData(jsonData: any): {
  products: Product[];
  categories: Category[];
  markets: string[];
  brands: string[];
} {
  let products: Product[] = [];
  
  if (jsonData.produtos && Array.isArray(jsonData.produtos)) {
    products = jsonData.produtos.map(transformJSONToProduct);
    console.log(`üì¶ ${products.length} produtos processados`);
  }
  
  // Marcar melhores pre√ßos por categoria
  const productsByCategory = products.reduce((acc, product) => {
    if (!acc[product.categoria]) {
      acc[product.categoria] = [];
    }
    acc[product.categoria].push(product);
    return acc;
  }, {} as Record<string, Product[]>);

  Object.keys(productsByCategory).forEach(categoria => {
    const categoryProducts = productsByCategory[categoria];
    const minPrice = Math.min(...categoryProducts.map(p => p.preco));
    categoryProducts.forEach(product => {
      if (product.preco === minPrice) {
        product.isMelhorPreco = true;
      }
    });
  });

  // Extrair categorias
  const categoriesFromProducts = Array.from(new Set(products.map(p => p.categoria)));
  
  const categories: Category[] = categoriesFromProducts.map(catId => {
    const productCount = products.filter(p => p.categoria === catId).length;
    
    return {
      id: catId,
      label: catId.charAt(0).toUpperCase() + catId.slice(1),
      icon: getCategoryIcon(catId),
      count: productCount
    };
  });

  // Adicionar categoria "all"
  categories.unshift({
    id: 'all',
    label: 'Todas as Categorias',
    icon: 'üõí',
    count: products.length
  });

  // Extrair mercados e marcas
  const markets = Array.from(new Set(products.map(p => p.loja).filter(Boolean)));
  const brands = Array.from(new Set(products.map(p => p.marca).filter(Boolean)));

  return { products, categories, markets, brands };
}

// ‚úÖ √çCONES DAS CATEGORIAS
function getCategoryIcon(categoria: string): string {
  const icons: Record<string, string> = {
    'bebidas': 'ü•§', 'carnes': 'ü•©', 'laticinios': 'ü•õ', 'graos': 'üåæ',
    'limpeza': 'üßΩ', 'higiene': 'üß¥', 'frutas': 'üçé', 'verduras': 'ü•¨',
    'hortifruti': 'ü•ï', 'massas': 'üçù', 'cafe': '‚òï', 'acucar': 'üçØ',
    'oleos': 'ü´í', 'biscoitos': 'üç™', 'paes': 'üçû', 'panificacao': 'ü•ñ',
    'congelados': 'üßä', 'doces': 'üç¨', 'temperos': 'üåø', 'enlatados': 'ü•´',
    'cereais': 'ü•£', 'petiscos': 'üçø', 'pereciveis': 'ü•ö', 'frios': 'üßÄ',
    'salgadinhos': 'üçø', 'condimentos': 'üå∂Ô∏è'
  };
  
  return icons[categoria] || 'üì¶';
}

// ‚úÖ HOOK PRINCIPAL
export function useProductData(): UseProductDataReturn {
  const [products, setProducts] = useState<Product[]>([]);
  const [allProducts, setAllProducts] = useState<Product[]>([]);
  const [categories, setCategories] = useState<Category[]>([]);
  const [markets, setMarkets] = useState<string[]>([]);
  const [brands, setBrands] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [dataSource, setDataSource] = useState<DataSourceType>('none');
  const [apiConnected, setApiConnected] = useState(false);
  const [jsonLoaded, setJsonLoaded] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState<string>('');

  const cacheRef = useRef<{
    products: Product[];
    timestamp: number;
  } | null>(null);

  // ‚úÖ CARREGAMENTO DO JSON (CAMINHO CORRIGIDO)
  const loadFromJSON = useCallback(async (): Promise<Product[]> => {
    try {
      console.log('üîÑ useProductData - Carregando dados do JSON...');
      
      // ‚úÖ CORRE√á√ÉO: Caminhos corretos para o arquivo
      const possiblePaths = [
        '/produtos-mock.json',           // ‚úÖ CAMINHO CORRETO
        './produtos-mock.json',          // ‚úÖ ALTERNATIVO
        '/public/produtos-mock.json',    // ‚úÖ FALLBACK
        'produtos-mock.json'             // ‚úÖ √öLTIMO RECURSO
      ];

      let jsonData = null;
      let loadedFrom = '';

      for (const path of possiblePaths) {
        try {
          console.log(`üîç useProductData - Tentando carregar de: ${path}`);
          const response = await fetch(path);
          if (response.ok) {
            jsonData = await response.json();
            loadedFrom = path;
            console.log(`‚úÖ useProductData - JSON carregado com sucesso de: ${path}`);
            break;
          } else {
            console.log(`‚ùå useProductData - Falha ao carregar de ${path}: ${response.status}`);
          }
        } catch (err) {
          console.log(`‚ùå useProductData - Erro ao tentar ${path}:`, err);
        }
      }

      if (!jsonData) {
        throw new Error('‚ùå Arquivo produtos-mock.json n√£o encontrado. Verifique se est√° em /public/produtos-mock.json');
      }

      console.log('üìä useProductData - Dados JSON carregados:', {
        produtos: jsonData.produtos?.length || 0,
        mercados: jsonData.mercados?.length || 0,
        metadata: jsonData.metadata
      });

      const { products, categories: cats, markets: mkts, brands: brds } = processJSONData(jsonData);
      
      setAllProducts(products);
      setCategories(cats);
      setMarkets(mkts);
      setBrands(brds);
      setJsonLoaded(true);
      setError(null);

      console.log(`üìä useProductData - Dados processados:`, {
        produtos: products.length,
        categorias: cats.length,
        mercados: mkts.length,
        marcas: brds.length,
        dispon√≠veis: products.filter(p => p.disponivel).length
      });
      
      return products;
    } catch (err) {
      console.error('‚ùå useProductData - Erro ao carregar JSON:', err);
      setJsonLoaded(false);
      setError(err instanceof Error ? err.message : 'Erro ao carregar dados locais');
      return [];
    }
  }, []);

  // ‚úÖ BUSCA INTELIGENTE
  const performSmartSearch = useCallback(async (query: string): Promise<Product[]> => {
    console.log(`üîç useProductData - Busca inteligente iniciada para: "${query}"`);
    
    // ‚úÖ VERIFICAR SE DADOS EST√ÉO CARREGADOS
    if (!allProducts || allProducts.length === 0) {
      console.warn('‚ö†Ô∏è useProductData - allProducts vazio, tentando carregar...');
      await loadFromJSON();
    }

    if (!query.trim()) {
      console.log('üìÑ useProductData - Query vazia, retornando todos os produtos');
      setProducts(allProducts);
      return allProducts;
    }

    setLoading(true);
    try {
      console.log(`üîç useProductData - Executando busca em ${allProducts.length} produtos`);
      
      const searchResults = searchProducts(allProducts, query);
      
      setProducts(searchResults);
      setDataSource('json');
      
      console.log(`‚úÖ useProductData - Busca conclu√≠da: ${searchResults.length} resultados para "${query}"`);
      return searchResults;
      
    } catch (err) {
      console.error('‚ùå useProductData - Erro na busca:', err);
      setError('Erro ao buscar produtos');
      setProducts([]);
      return [];
    } finally {
      setLoading(false);
    }
  }, [allProducts, loadFromJSON]);

  // ‚úÖ BUSCA POR CATEGORIA
  const loadProductsByCategory = useCallback(async (categoryId: string): Promise<Product[]> => {
    console.log(`üìÇ useProductData - Carregando categoria: ${categoryId}`);
    
    setLoading(true);

    try {
      let filteredProducts: Product[];

      if (categoryId === 'all') {
        filteredProducts = allProducts;
        console.log(`üìÇ useProductData - Categoria "all": ${filteredProducts.length} produtos`);
      } else {
        filteredProducts = searchByCategory(allProducts, categoryId);
        console.log(`üìÇ useProductData - Categoria "${categoryId}": ${filteredProducts.length} produtos`);
      }

      setProducts(filteredProducts);
      setDataSource('json');
      
      return filteredProducts;
      
    } catch (err) {
      console.error('‚ùå useProductData - Erro ao filtrar por categoria:', err);
      setError('Erro ao carregar categoria');
      return [];
    } finally {
      setLoading(false);
    }
  }, [allProducts]);

  // ‚úÖ SUGEST√ïES INTELIGENTES
  const getSmartSuggestions = useCallback((query: string = ''): string[] => {
    const suggestions = generateSmartSuggestions(allProducts, query);
    console.log(`üí° useProductData - Sugest√µes para "${query}":`, suggestions);
    return suggestions;
  }, [allProducts]);

  // ‚úÖ CARREGAMENTO INICIAL
  const loadProducts = useCallback(async (): Promise<void> => {
    console.log('üöÄ useProductData - Iniciando carregamento de produtos...');
    
    setLoading(true);
    setError(null);

    try {
      const jsonProducts = await loadFromJSON();
      
      if (jsonProducts.length > 0) {
        setProducts(jsonProducts);
        setDataSource('json');
        
        // Cache dos produtos
        cacheRef.current = {
          products: jsonProducts,
          timestamp: Date.now()
        };
        
        console.log('‚úÖ useProductData - Sistema PRECIVOX carregado com sucesso!');
        console.log(`üìä useProductData - Total de produtos dispon√≠veis: ${jsonProducts.length}`);
      } else {
        setDataSource('none');
        console.warn('‚ö†Ô∏è useProductData - Nenhum produto foi carregado');
      }

    } catch (err) {
      console.error('‚ùå useProductData - Erro no carregamento:', err);
      setError('Erro ao carregar dados do sistema');
      setDataSource('none');
    } finally {
      setLoading(false);
    }
  }, [loadFromJSON]);

  // ‚úÖ RECARREGAR DADOS
  const reloadData = useCallback(async (): Promise<void> => {
    console.log('üîÑ useProductData - Recarregando dados...');
    cacheRef.current = null;
    await loadProducts();
  }, [loadProducts]);

  // ‚úÖ LIMPAR CACHE
  const clearCache = useCallback((): void => {
    cacheRef.current = null;
    console.log('üóëÔ∏è useProductData - Cache limpo');
  }, []);

  // ‚úÖ EFEITO INICIAL - CARREGAMENTO AUTOM√ÅTICO
  useEffect(() => {
    console.log('üé¨ useProductData - Montando hook...');
    loadProducts();
  }, []);

  // ‚úÖ LOGS DE DEBUG
  useEffect(() => {
    console.log('üìà useProductData - Estado atualizado:', {
      allProducts: allProducts.length,
      products: products.length,
      categories: categories.length,
      markets: markets.length,
      brands: brands.length,
      loading,
      jsonLoaded,
      error,
      dataSource
    });
  }, [allProducts, products, categories, markets, brands, loading, jsonLoaded, error, dataSource]);

  return {
    products,
    allProducts,
    categories,
    markets,
    brands,
    loading,
    dataSource,
    apiConnected,
    jsonLoaded,
    error,
    loadProducts,
    searchProducts: performSmartSearch, // ‚úÖ FUN√á√ÉO PRINCIPAL DE BUSCA
    loadProductsByCategory,
    reloadData,
    clearCache,
    getSmartSuggestions,
    searchTerm,
    setSearchTerm
  };
}

export default useProductData;